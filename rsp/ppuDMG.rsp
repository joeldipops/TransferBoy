#include <ucode.S>
#include "../global.h"
#include "init.rsp"
#include "rspIncludes.rsp"
#include "rdp.rsp"

###------------------------------------------
# Renders a scan line of the gameboy screen.
#
###------------------------------------------

###
# Constants
###

# OAM Structure
.eqv Oam_Y_BLOCK, 0x00
.eqv Oam_X_BLOCK, 0x01
.eqv Oam_TILE_INDEX, 0x02
.eqv Oam_FLAGS, 0x03

# Oam_FLAGS Structure
.eqv Oam_PRIORITY,  0b10000000
.eqv Oam_Y_FLIP,    0b01000000
.eqv Oam_X_FLIP,    0b00100000

.eqv OAM_X_OFFSET, 0x08
.eqv OAM_Y_OFFSET, 0x10

.eqv OAM_SIZE, 0xA0
.eqv TILE_WIDTH, 0x08
.eqv TILES_PER_WIDTH, 0x20
.eqv TILE_SIZE, 0x10 # 8x8 2b pixels is 16B
.eqv SPRITE_COUNT, OAM_SIZE / 4 # 40 sprites in OAM
.eqv SPRITE_LIMIT, 0x0A # 10 sprites per scanline


# RSP Interface Structure
.eqv RspIn_IS_BUSY, 0x00
.eqv RspIn_VRAM_BASE, 0x04
.eqv RspIn_HRAM_BASE, 0x08
.eqv RspIn_OAM_BASE, 0x0C
.eqv RspIn_OUT_ADDRESS, 0x10
.eqv RspIn_SCREEN_POSITION, 0x14
.eqv RspIn_RECTANGLE_SIZE, 0x18

.eqv INTERFACE_SIZE, 0x20

# PPU Settings Structure
## These are the gameboy LCD registers.

.eqv Ppu_LCD_CONTROL, 0x0
.eqv Ppu_LCD_STATUS, 0x1
.eqv Ppu_BACKGROUND_SCROLL_Y, 0x2
.eqv Ppu_BACKGROUND_SCROLL_X, 0x3
.eqv Ppu_CURRENT_LINE, 0x4         # This is the line we're drawing.
.eqv Ppu_NEXT_INTERRUPT_LINE, 0x5  # Probably not important.  Interrupts to be handled elsewhere?
.eqv Ppu_DMA_SOURCE, 0x6
.eqv Ppu_BACKGROUND_PALETTE, 0x7
.eqv Ppu_SPRITE_PALETTE_0, 0x8
.eqv Ppu_SPRITE_PALETTE_1, 0x9
.eqv Ppu_WINDOW_TOP, 0xA
.eqv Ppu_WINDOW_LEFT, 0xB
.eqv PPU_SETTINGS_SIZE, 0x10

# LCDC Flags structure
.eqv Lcdc_LCD_SWITCH,           0b10000000
.eqv Lcdc_WINDOW_TILE_MAP,      0b01000000
.eqv Lcdc_WINDOW_SWITCH,        0b00100000
.eqv Lcdc_TILE_DATA,            0b00010000
.eqv Lcdc_BACKGROUND_TILE_MAP,  0b00001000
.eqv Lcdc_SPRITE_SIZE,          0b00000100
.eqv Lcdc_SPRITE_SWITCH,        0b00000010
.eqv Lcdc_LCD_PRIORITY,         0b00000001

.eqv DMEM_SIZE, 0x1000
.eqv BUFFER_SIZE, GB_LCD_WIDTH * 2 # ( x2 for 16bit colours)


.eqv CacheEntry_HEADER, 0x00
.eqv CacheEntry_DATA, 0x04
.eqv CACHE_ENTRY_SIZE, 0x14

.eqv TILE_CACHE_ENTRIES, 50

.eqv TILE_MAP_0_OFFSET, 0x1800
.eqv TILE_MAP_1_OFFSET, 0x1C00

.eqv TILE_DATA_0_OFFSET, 0x0800
.eqv TILE_DATA_1_OFFSET, 0x0000
.eqv PPU_SETTINGS_OFFSET, 0x0040

###
# Memory Map
###


.eqv PALETTE_2_BIT, 0x7F0 # Temp DMG Palette register values.
.eqv STACK_BOTTOM,  0x800 # Adjust the stack size as neccessary
.eqv STACK_TOP,     0x830
.eqv N64_BUFFER,    0x840 # 160 42bit pixels per scan-line.
.eqv GB_BUFFER,     0xAC0 # 160 2bit pixels per scan-line = 40bytes
.eqv LINE_TILE_MAP, 0xAE8 # 32B 1 for each tile across the background (though we only see 20 tiles at a time.)
.eqv TILE_CACHE,    0xB08 # 50 possible tiles with 20B cache entries (4B header + 16B/tile with 2b colours).
.eqv PPU_SETTINGS,  0xEF0
.eqv INPUT,         0xF00
.eqv OAM_CACHE,     0xF40 # 10 OAM entries per scanline at 4B/entry
.eqv OAM_MIRROR,    0xF50 # GB - N64 Colour translation.
.eqv MONOCHROME_PALETTE, 0xFF0

### Palette Values

.eqv LIGHTEST,0x0000FFFF
.eqv LIGHTER, 0x0000A529
.eqv DARKER,  0x00005295
.eqv DARKEST, 0x00000001



###
# Register aliases
###

# Address to store massaged pixels where they will be picked up by the RDP
.set $OUT_BUFFER_ADDRESS, $s0

# Number of pixels left to render in current iteration.
.set $PIXEL_COUNTER, $s1

# Cached Height may not be necessary
.set $RECTANGLE_HEIGHT, $s2

# Cached value of LCDC bit 2 flag
.set $IS_8x16_MODE, $s3

# Left and Top position of line to render.
.set $START_POSITION, $s4

# Length & Width of the line to draw in N64 pixels so it can be scaled.
.set $RECTANGLE_SIZE, $s5

.set $SCAN_LINE, $s6

.set $CACHE_POINTER, $s7

.set $VRAM_TILE_DATA_ADDRESS, $s8

###
# Lays a DMG palette out in an easily referencable table in memory.
#
# @input a0 The palette to set.
###
setPalette:
    .set $palette, $a0

    andi $t0, $palette, 0b00000011
    sb $t0, PALETTE_2_BIT($0)

    srl $t0, $palette, 2
    andi $t0, $t0, 0b00000011
    sb $t0, (PALETTE_2_BIT + 1)($0)

    srl $t0, $palette, 4
    andi $t0, $t0, 0b00000011
    sb $t0, (PALETTE_2_BIT + 2)($0)

    srl $t0, $palette, 6
    andi $t0, $t0, 0b00000011
    sb $t0, (PALETTE_2_BIT + 3)($0)

    .set $palette, 0
    jr $ra


###
# Takes a 2bit DMG colour index and converts to a 16bit n64 colour.
#
# @input a0 the dmg colour index (0 - 3)
# @output r0 the 16bit dmg colour.
###
massageMonochrome:
    # zero out irrelevant bits
    andi $a0, $a0, 3
    # and multiply by four since we deal with 32bit addresses
    sll $a0, $a0, 2
    lw $r0, MONOCHROME_PALETTE($a0)
    jr $ra

###
# Gets the address of a tile.
# Either from the cache or the tile is DMA'd in and cached.
# @input $a0 The tile ID.
# @output $r0 Pointer to the tile data.
###
cacheGetTile:
    .set $tileId, $a0
    .set $pointer, $a1

    # when there's nothing in the cache, short-circuit.
    addi $t0, $0, TILE_CACHE
    beq $t0, $CACHE_POINTER, notFound

    # Set the flag so we're never comparing 0 to 0.
    lui $t0, 0x8000
    or $tileId, $tileId, $t0

    # Start at the current end of the cache and work back to the start.
    add $pointer, $0, $CACHE_POINTER

    .whileNotFound:
        addi $pointer, $pointer, -1 * CACHE_ENTRY_SIZE

        # Check if tile id matches cache entry header.
        lw $t0, 0($pointer)
        bne $t0, $tileId, .whileNotFound_continue

            # We've found it. Return a pointer to the data.
            addi $r0, $pointer, 0x04
            jr $ra

        .whileNotFound_continue:
        # Check that $pointer is still greater than the bottom of the cache
        addi $t0, $pointer, -1 * TILE_CACHE
    bltz $t0, .whileNotFound
    notFound:

    # Tile isn't in the cache yet, so we need to DMA it in.

    ## Set the tile id at the cache pointer as the header.
    ### set a flag so we don't compare 0 to 0
    lui $t0, 0x8000
    or $tileId, $tileId, $t0
    sw $tileId, 0($CACHE_POINTER)
    ### Increment cache pointer so we can add data.
    addi $CACHE_POINTER, $CACHE_POINTER, 0x04

    ## Multiply tile ID by 16 to get address offset.
    sll $tileId, $tileId, 4
    ## Which is added to the address base.
    add $tileId, $tileId, $VRAM_TILE_DATA_ADDRESS

    stackPush 2
    dmaIn_destR $tileId, $CACHE_POINTER, TILE_SIZE
    stackPop 2

    # Now that data has been loaded, return a pointer to it.
    add $r0, $0, $CACHE_POINTER

    ## Increment cache pointer to the next empty entry.
    addi $CACHE_POINTER, $CACHE_POINTER, TILE_SIZE
    jr $ra

.set $tileId, 0
.set $pointer, 0

###
# Sets in DMEM up to 10 OAM entries for sprites that will appear on this scan line.
###
.macro transferOAM
    .set $screenSpritesRemaining, $t1
    .set $lineSpritesRemaining, $t2
    .set $y1, $t3
    .set $y2, $t4
    .set $entry, $t5

    ## Find the sprites relevant to the current scanline so we don't have to loop through 40 sprites every pixel.

    lw $t0, (INPUT + RspIn_OAM_ADDRESS)($0)
    dmaIn $t0, OAM_MIRROR, OAM_SIZE

    addi $screenSpritesRemaining, $0, SPRITE_COUNT
    addi $lineSpritesRemaining, $0, SPRITE_LIMIT
    .whileHasOam:
        # Load the OAM for the current sprite

        ## Figure out what sprite we are on.
        addi $t0, $0, SPRITE_COUNT
        sub $t0, $t0, $screenSpritesRemaining
        ## Multiply by four to get the address offset.
        sll $t0, $t0, 2
        lw $entry, OAM_MIRROR($t0)

        ## We care about the Y position, which is the lowest byte
        andi $y1, $entry, 0x000000FF

        # Test that the sprite will appear on this scanline
        addi $y1, $0, OAM_Y_OFFSET

        ## $t3 is lower bound, $t0 is upper bound.  Double it if 8x16 mode is on.
        addi $y2, $y1, 8
        beq $IS_8x16_MODE, $0, 1f
            addi $y2, $y2, 8
        1:

        ## if bottom of the sprite is greater than the current scan line, we don't need to render it here.
        sub $t0, $y1, $SCAN_LINE
        # Gotta shift by 16 both times because OAM starts at scan line -16
        addi $t0, $t0, -1 * OAM_Y_OFFSET
        bgtz $t0, .whileHasOam_continue

        ## if top of the sprite is less than the current scan line, skip that too.
        sub $t0, $SCAN_LINE, $y2
        addi $t0, $t0, OAM_Y_OFFSET
        bgtz $t0, .whileHasOam_continue

            # Cache a sprite that exists on this scan line.

            ## Calculate the destination offset to cache at.
            addi $t0, $0, SPRITE_LIMIT
            sub $t0, $t0, $lineSpritesRemaining
            sll $t0, $t0, 2 # x4 since OAM entry is 4B 

            ## And cache it
            sw $entry, OAM_CACHE($t0)

            # There is a limit of 10 sprites per scanline.
            ## Once we've found that many relevant sprites, we're done.

            ## I believe that the limit should actually be done from left to right (i think), but assumption is most 
            ## code won't break the limit anyway.
            ## Will create a job to improve accuracy of this once general case is working.
            addi $lineSpritesRemaining, $lineSpritesRemaining, -1
            bgtz $lineSpritesRemaining, .whileHasOam_break

        .whileHasOam_continue:

        addi $screenSpritesRemaining, $screenSpritesRemaining, -1
        bgtz $screenSpritesRemaining, .whileHasOam
    .whileHasOam_break:

    .set $spriteCounter, $t1
    .set $spriteCount, $t2
    addi $t0, $0, SPRITE_LIMIT
    sub $spriteCount, $t0, $lineSpritesRemaining
    add $spriteCounter, $0, $spriteCount

    # Set them all to 0 so we'll error if try to use them as registers.
    .set $screenSpritesRemaining, 0
    .set $lineSpritesRemaining, 0
    .set $y1, 0
    .set $y2, 0
.endm

###
# Draws pixels for the window if it appears on this scanline.
###
.macro processWindow
    nop
.endm

###
# Draws any sprites that apear on this scanline
###
.macro processSprites
    .set $entry, $t3
    .set $x1, $t4
    .set $x2, $t5

    # Loop through the oam cache
    .whileHasSprites:
        # Get the relevant OAM entry
        sub $t0, $spriteCount, $spriteCounter
        ## Multiply by 4 to get the address offset.
        sll $t0, $t0, 2
        lw $entry, OAM_CACHE($t0)

        # Does this sprite appear in this x position?
        andi $x1, $t0, OAM_X_OFFSET
        addi $x2, $x1, TILE_WIDTH

        ## if left of the sprite is greater than the current pixel, we're not interested right now.
        sub $t0, $x1, $PIXEL_COUNTER
        ## Gotta shift by 8, OAM starts at x-loc -8
        addi $t0, $t0, -1 * OAM_X_OFFSET
        bgtz $t0, .whileHasSprites_continue

        ## if right of the sprite is less than the current pixel, skip that too.
        sub $t0, $PIXEL_COUNTER, $x2
        add $t0, $t0, OAM_X_OFFSET
        bgtz $t0, .whileHasSprites_continue

            # Get the tile index from the OAM entry.
            liw $t0, 0x00FF0000
            and $t0, $entry, $t0
            srl $t0, $t0, 16
            # And the tile data from the cache.
            add $a0, $0, $entry
            jal cacheGetTile

            # For the visible width of this sprite
                # Find the pixel that correlates to this x position.
                # Run it through the palette
                # Check it against priority

                # add it to the buffer.
                #sw $r0, 0($GB_BUFFER_POINTER)

                # update indices
                #addi $GB_BUFFER_POINTER, $GB_BUFFER_POINTER, 0x02
                addi $PIXEL_COUNTER, $PIXEL_COUNTER, -1

        .whileHasSprites_continue:
        addi $spriteCounter, $spriteCounter, -1
    bgtz $spriteCounter, .whileHasSprites

    .set $entry, 0
    .set $x1, 0
    .set $x2, 0
.endm


### Draws pixels for the background.
.macro processBackground
    .set $tileMap, $t2
    .set $currentPixel, $t3
    .set $gbBufferCursor, $t4
    .set $endLinePixel, $t5
    .set $shiftBy, $t6
    .set $tileLine, $t7

    # TODO: Check Lcdc_LCD_PRIORITY. If it's 0, skip all of this and just draw white pixels.

    # Set the palette
    lbu $a0, (PPU_SETTINGS + Ppu_BACKGROUND_PALETTE)($0)
    jal setPalette

    # Find the bit of VRAM that corresponds to the tiles on this line.
    lb $t0, PPU_SETTINGS + Ppu_LCD_CONTROL($0)
    andi $t0, $t0, Lcdc_BACKGROUND_TILE_MAP
    bne $t0, $0, 1f
        addi $tileMap, $0, TILE_MAP_0_OFFSET
        j 2f
    1:
        addi $tileMap, $0, TILE_MAP_1_OFFSET
    2:

    # Figure out what line of the background we need to start with by adding the SCY register
    lbu $t0, (PPU_SETTINGS + Ppu_BACKGROUND_SCROLL_Y)($0)
    add $t0, $t0, $SCAN_LINE
    # wrap around on 256
    andi $t0, $t0, 0xFF

    # DMA in a line of the tile map, 
    ## Divide by 8 to get the tile line, then multiply by 32
    ### Yes I'm trying to wrap my head around why I can't just << 2, but for scan-line 1, this would be tile 4 when it should be tile 0...
    srl $t0, $t0, 3
    sll $t0, $t0, 5

    # add to tile map to get the address in GB Memory.
    add $tileMap, $tileMap, $t0

    ## And add to this to get the location in N64 memory.
    lw $t0, (INPUT + RspIn_VRAM_BASE)($0)
    add $tileMap, $tileMap, $t0

    # DMA it in.
    dmaIn $tileMap, LINE_TILE_MAP, 0x20

    add $gbBufferCursor, $0, $0

    # Find starting pixel
    lbu $currentPixel, (PPU_SETTINGS + Ppu_BACKGROUND_SCROLL_X)($0)
    addi $endLinePixel, $currentPixel, TILE_WIDTH * TILES_PER_WIDTH

    3: #.whileBgHasPixels:
        # Divide by 8 to get the tile.
        srl $t0, $currentPixel, 3

        lbu $a0, LINE_TILE_MAP($t0)

        jal cacheGetTile

        # which line of the tile are we on

        ## a % b == a & ( b -1 ) if b is a power of 2
        and $t0, $SCAN_LINE, TILE_WIDTH - 1
        ## Multiply by two to get the number of bytes to skip.
        sll $t0, $t0, 1
        ## $r0 now points to the line of the tile we want.
        add $r0, $r0, $t0

        addi $shiftBy, $0, 8
        add $tileLine, $0, $0

        # gb tile data is NOT stored with the pixels in order like:
        # 11001001 01011101
        # 00112233 44556677

        # but with the pixels spread across two bytes like:
        # 11001001 01011101
        # 01234567 01234567

        .whileHasPixels:
            addi $shiftBy, $shiftBy, -1

            # Grab two bytes from the tile (8 pixels).
            lhu $t0, 0($r0)

            # Shift so that the two bits are in bit 0 of both pixels.
            srlv $t0, $t0, $shiftBy

            # Put both pixels next to each other.
            andi $t1, $t0, 0x100
            andi $t0, $t0, 0x001

            srl $t1, $t1, 7
            or $t0, $t0, $t1

            # Look up the palette
            lb $t0, PALETTE_2_BIT($t0)

            sll $t1, $t0, 7
            andi $t1, $t1, 0x100
            andi $t0, $t0, 0x001
            or $t0, $t0, $t1

            # Patch it back to $tileLine
            sllv $t0, $t0, $shiftBy
            or $tileLine, $tileLine, $t0

        bgtz $shiftBy, .whileHasPixels

        # TODO - shift as needed for part tiles
        # sll $t0, $t0, ???
        #andi $t0, $t0, 0xFFFF
        sh $tileLine, GB_BUFFER($gbBufferCursor)

        # Advance buffer two bytes
        addi $gbBufferCursor, $gbBufferCursor, 2 # TODO: part tiles

        # Which is 8 pixels.
        addi $currentPixel, $currentPixel, 8 # TODO: part tiles
    bne $currentPixel, $endLinePixel, 3b # .whileBgHasPixels

    .set $tileMap, 0
    .set $currentPixel, 0
    .set $gbBufferCursor, 0
    .set $endLinePixel, 0
    .set $shiftBy, 0
    .set $tileLine, 0
.endm

.macro massagePixels
    .set $n64Cursor, $t2
    .set $gbCursor, $t3
    .set $shiftBy, $t4
    .set $pixelCounter, $t5
    .set $currentWord, $t6

    addi $pixelCounter, $0, GB_LCD_WIDTH
    add $gbCursor, $0, $0
    add $n64Cursor, $0, $0

    1: # whileHasPixels
        # get 8 pixels from memory
        lhu $currentWord, GB_BUFFER($gbCursor)

        addi $shiftBy, $0, 8
        .whileInWord:
            addi $shiftBy, $shiftBy, -1

            # Shift so that the two bits are in bit 0 of both pixels.
            srlv $a0, $currentWord, $shiftBy

            # Put both pixels next to each other.
            andi $t0, $a0, 0x100
            andi $a0, $a0, 0x001
            srl $t0, $t0, 7
            or $a0, $a0, $t0

            # massage it from gameboy format to n64 format.
            jal massageMonochrome

            # and push on to the buffer.
            sh $r0, N64_BUFFER($n64Cursor)

            addi $n64Cursor, $n64Cursor, 0x02

        bgtz $shiftBy, .whileInWord

        # increment the cursor and decrement the counter.
        addi $gbCursor, $gbCursor, 0x02
        addi $pixelCounter, $pixelCounter, -8

    bgtz $pixelCounter, 1b # whileHasPixels

    .set $n64Cursor, 0
    .set $gbCursor, 0
    .set $pixelCounter, 0
    .set $shiftBy, 0
    .set $currentWord, 0
.endm

###
# Sets the RDP to draw red rectangles.
main:
    # Set the RSP busy flag.
    addi $t0, $0, SP_STATUS_BUSY_ON
    mtc0 $t0, $RSP_STATUS

    # init stack pointer.
    addi $sp, $0, STACK_TOP

    # Bring in the configuration.
    liw $t0, RSP_INTERFACE_ADDRESS
    dmaIn $t0, INPUT, INTERFACE_SIZE

    # Load and cache the gameboy LCD registers.
    lw $t0, (INPUT + RspIn_HRAM_BASE)($0)
    addi $t0, $t0, PPU_SETTINGS_OFFSET
    dmaIn $t0, PPU_SETTINGS, PPU_SETTINGS_SIZE

    # Check whether the LCD is turned on, and if not, skip all this shebang.
    lb $t0, (PPU_SETTINGS + Ppu_LCD_CONTROL)($0)

    andi $t0, $t0, Lcdc_LCD_SWITCH
        beq $t0, $0, done

    # Initialise rendering of the line.

    ## Initialise some registers with constants.
    ## TODO - allow this cache to persist across scan-lines.
    addi $CACHE_POINTER, $0, TILE_CACHE

    ## Stash config in some registers so whole memory space is available.
    lw $OUT_BUFFER_ADDRESS, INPUT + RspIn_OUT_ADDRESS($0)

    lw $START_POSITION, INPUT + RspIn_SCREEN_POSITION($0)
    lw $RECTANGLE_SIZE, INPUT + RspIn_RECTANGLE_SIZE($0)
    andi $RECTANGLE_HEIGHT, $RECTANGLE_SIZE, 0x0000FFFF

    ## Set up monochrome colour palette in memory
    liw $t0, LIGHTEST
    sw $t0, MONOCHROME_PALETTE($0)
    liw $t0, LIGHTER
    sw $t0, (MONOCHROME_PALETTE + 4)($0)
    liw $t0, DARKER
    sw $t0, (MONOCHROME_PALETTE + 8)($0)
    liw $t0, DARKEST
    sw $t0, (MONOCHROME_PALETTE + 0xC)($0)

    ## Cache the current scan line.
    lbu $SCAN_LINE, (PPU_SETTINGS + Ppu_CURRENT_LINE)($0)

    ## Cache if we're in 8x16 sprite mode.
    lbu $IS_8x16_MODE, (PPU_SETTINGS + Ppu_LCD_CONTROL)($0)
    andi $IS_8x16_MODE, $IS_8x16_MODE, Lcdc_SPRITE_SIZE

    ## Cache VRAM tile data address
    lb $t0, PPU_SETTINGS + Ppu_LCD_CONTROL($0)
    andi $t0, Lcdc_TILE_DATA
    bne $t0, $0, 1f
        addi $VRAM_TILE_DATA_ADDRESS, $0, TILE_DATA_0_OFFSET
        j 2f
    1:
        addi $VRAM_TILE_DATA_ADDRESS, $0, TILE_DATA_1_OFFSET
    2:
    lw $t0, INPUT + RspIn_VRAM_BASE
    add $VRAM_TILE_DATA_ADDRESS, $VRAM_TILE_DATA_ADDRESS, $t0

    # Build up this scanline to a buffer than can be rendered as a texture.
    transferOAM

    ## Draw the window
    processWindow

    ## Then the background
    processBackground

    # Finally draw sprites
    #processSprites

    # Massage the colours to n64 16bit colours.
    massagePixels

    # Ask the RDP to render the line we just built.

    ## Sync before loading a new texture.
    syncPipe

    ## DMA the data back to DRAM so that the RDP can pick it up.
    dmaOut N64_BUFFER, $OUT_BUFFER_ADDRESS, BUFFER_SIZE

    ## Tell RDP where to look for texture data.
    setTextureImage RGBA_FORMAT, COLOUR_DEPTH_16, GB_LCD_WIDTH, $OUT_BUFFER_ADDRESS

    ## Set up a tile now that the RDP has the data.
    setTile 1, RGBA_FORMAT, COLOUR_DEPTH_16, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

    ## Give tile a size & shape
    loadTile 1, 0, 0, GB_LCD_WIDTH, 1

    # Calculate where to draw the line.
    add $a0, $START_POSITION, $0
    srl $a0, $a0, 16
    andi $a1, $START_POSITION, 0x0000FFFF

    add $a2, $RECTANGLE_SIZE, $0
    srl $a2, $a2, 16

    add $a2, $a2, $a0
    add $a3, $RECTANGLE_HEIGHT, $a1

    ## Draw a rectangle with the texture we have set up
    textureRectangle 1, $a0, $a1, $a2, $a3, 0, 0, 2048, 512

    # Clean-up now that we're done.

    ## Reset DRAM flag that says we're done with this work.
done:
    # Lift the IsBusy flag
    addi $t0, $0, SP_STATUS_BUSY_OFF
    mtc0 $t0, $RSP_STATUS

# job done
stall:
    nop
    j stall
    nop

break
# Fill remainder with break instruction
#.org 2048, 0x0000000D
